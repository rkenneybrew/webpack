"use strict";

var _crypto = _interopRequireDefault(require("crypto"));
var _fs = require("fs");
var _path = require("path");
var _util = _interopRequireDefault(require("util"));
var _v = require("v8");
var _findCacheDir = _interopRequireDefault(require("find-cache-dir"));
var _loaders = require("./utils/loaders");
var _replaceComposes = _interopRequireDefault(require("./utils/replaceComposes"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const cacheDir = (0, _findCacheDir.default)({
  name: 'astroturf-loader'
});
try {
  (0, _fs.mkdirSync)(cacheDir, {
    recursive: true
  });
} catch (error) {
  console.error('astroturf/loader could not create cache directory', error);
}
const inMemoryStyleCache = new Map();
const hash = name => `${_crypto.default.createHash('sha1').update(name).digest('hex')}.cache`;
const cache = {
  async set(source, newStyles) {
    const styles = (await this.get(source)) || new Map();
    inMemoryStyleCache.set(source, styles);
    newStyles.forEach(style => {
      styles.set(style.identifier, style);
    });
    try {
      await _fs.promises.writeFile(`${cacheDir}/${hash(source)}`, (0, _v.serialize)(styles));
    } catch {
      /* ignore */
    }
  },
  async get(source) {
    let styles = inMemoryStyleCache.get(source);
    if (!styles) {
      try {
        styles = (0, _v.deserialize)(await _fs.promises.readFile(`${cacheDir}/${hash(source)}`));
        inMemoryStyleCache.set(source, styles);
      } catch {
        /* ignore */
      }
    }
    return styles;
  }
};
const debug = _util.default.debuglog('astroturf:loader');
module.exports = async function loader(content, _map, meta) {
  const {
    resourcePath
  } = this;
  const loaderOpts = this.getOptions() || {};
  const cb = this.async();
  const loadModule = _util.default.promisify((request, done) => this.loadModule(request, (err, _, _1, module) => done(err, module)));
  if (loaderOpts.style) {
    const styleId = new URLSearchParams(this.resourceQuery || '').get('styleId');
    const styles = await cache.get(resourcePath);
    let style = styles == null ? void 0 : styles.get(styleId);
    if (!style) {
      var _inMemoryStyleCache$g;
      await loadModule(resourcePath);
      style = (_inMemoryStyleCache$g = inMemoryStyleCache.get(resourcePath)) == null ? void 0 : _inMemoryStyleCache$g.get(styleId);
    }
    if (!style) {
      return cb(new Error(`Could not resolve style ${styleId} in file ${resourcePath}`));
    }
    if (!this._module.matchResource) this._module.matchResource = style.absoluteFilePath;
    return cb(null, style.value);
  }
  function getLoaderRequest(from, to, id) {
    const cssBase = (0, _path.basename)(to);
    const file = `${cssBase}!=!astroturf/inline-loader?style=1!${from}?styleId=${id}`;
    return file;
  }
  const resolve = _util.default.promisify(this.resolve);
  const dependencies = [];
  const buildDependency = async request => {
    const resource = await resolve((0, _path.dirname)(resourcePath), request);
    return loadModule(resource);
  };
  function resolveDependency(interpolation, localStyle, node) {
    const {
      identifier,
      request
    } = interpolation;
    if (!interpolation.identifier) return null;
    const {
      loc
    } = node;
    const memberProperty = 'property' in node && node.property.name;
    const imported = `###ASTROTURF_IMPORTED_${dependencies.length}###`;
    const source = `###ASTROTURF_SOURCE_${dependencies.length}###`;
    debug(`resolving dependency: ${request}`);
    dependencies.push(buildDependency(request).then(module => {
      const styles = inMemoryStyleCache.get(module.resource);
      const style = styles == null ? void 0 : styles.get(identifier);
      if (!style) {
        throw (0, _loaders.buildDependencyError)(content, interpolation, Array.from((styles == null ? void 0 : styles.values()) || []), module.resource, loc);
      }
      debug(`resolved request to: ${style.absoluteFilePath}`);
      const styleReq = getLoaderRequest(module.resource, style.absoluteFilePath, style.identifier);

      // replace composes first bc we need need to use a different identifier
      localStyle.value = (0, _replaceComposes.default)(localStyle.value, match => match.replace(source, styleReq).replace(imported, style.type === 'stylesheet' ? memberProperty : 'cls2'));

      // replace selector interpolations
      localStyle.value = localStyle.value.replace(source, styleReq).replace(imported, style.type === 'stylesheet' ? memberProperty : 'cls1');
    }));
    return {
      source,
      imported
    };
  }
  try {
    const options = await (0, _loaders.resolveOptions)(this);
    options.getRequirePath = getLoaderRequest;
    const {
      styles = [],
      changeset
    } = (0, _loaders.collectStyles)(content, resourcePath, resolveDependency, options);
    if (meta) {
      meta.styles = styles;
    }
    if (!styles.length) {
      return cb(null, content);
    }
    return Promise.all(dependencies).then(async () => {
      await cache.set(resourcePath, styles);
      const result = (0, _loaders.replaceStyleTemplates)(resourcePath, content, changeset, this.sourceMap);
      cb(null, result.code, result.map);
    }).catch(cb);
  } catch (err) {
    return cb(err);
  }
};