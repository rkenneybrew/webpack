#!/usr/bin/env node

/* eslint-disable no-await-in-loop */
"use strict";

exports.__esModule = true;
exports.handler = handler;
var _promises = require("fs/promises");
var _path = _interopRequireDefault(require("path"));
var _processor = _interopRequireDefault(require("@modular-css/processor"));
var _output = _interopRequireDefault(require("@modular-css/processor/lib/output"));
var _globby = _interopRequireDefault(require("globby"));
var _postcssScss = _interopRequireDefault(require("postcss-scss"));
var _resolve = _interopRequireDefault(require("resolve"));
var _yargs = _interopRequireDefault(require("yargs"));
var _config = _interopRequireDefault(require("./config"));
var _createFilename = _interopRequireDefault(require("./utils/createFilename"));
var _loaders = require("./utils/loaders");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * use comma seperators for composes classes
 */
function composesPlugin(css) {
  css.walkDecls('composes', decl => {
    const [, classes, rest = ''] = decl.value.match(/(.+?)(from.*)?$/);

    // eslint-disable-next-line no-param-reassign
    decl.value = `${classes.split(/,?\s+/).filter(Boolean).join(', ')} ${rest}`;
  });
}
composesPlugin.postcssPlugin = 'compat-composes-delimiter';
const exportPlugin = () => {
  function collect(rule, result) {
    const exported = Object.create(null);
    rule.walkDecls(decl => {
      exported[decl.prop] = decl.value;
    });
    rule.remove();
    result.messages.push({
      type: 'css-module-loader',
      plugin: 'modular-css-export-icss',
      exports: exported
    });
  }
  return {
    postcssPlugin: 'astroturf/icss-export',
    AtRule: {
      export: (rule, {
        result
      }) => {
        collect(rule, result);
      }
    },
    Rule(rule, {
      result
    }) {
      if (rule.selector === ':export') {
        collect(rule, result);
      }
    }
  };
};
exportPlugin.postcss = true;
const stripInlineComments = () => {
  return {
    postcssPlugin: 'astroturf/strip-inline-comments',
    Comment(comment) {
      if (comment.raws.inline) comment.remove();
    }
  };
};
stripInlineComments.postcss = true;
async function handler({
  files,
  outFile,
  configFile
}) {
  const styles = new Map();
  const outFiles = [];
  const options = configFile ? await _config.default.load(configFile) : null;
  const deps = new Map();
  const dependencyResolver = ({
    request,
    identifier
  }, localStyle) => {
    const source = _resolve.default.sync(request, {
      basedir: _path.default.dirname(localStyle.absoluteFilePath)
    });
    let styleFile = (0, _createFilename.default)(request, {
      extension: '.css'
    }, identifier);
    styleFile = _path.default.resolve(_path.default.dirname(localStyle.absoluteFilePath), styleFile);
    deps.set(styleFile, source);
    return {
      source: styleFile
    };
  };
  async function runAstroturf(content, file) {
    const existing = styles.get(file);
    if (existing) return existing;
    const fileOptions = options || (await _config.default.search(file));
    const result = (0, _loaders.collectStyles)(content, file, dependencyResolver, {
      ...(fileOptions == null ? void 0 : fileOptions.config),
      writeFiles: false,
      extension: '.css',
      generateInterpolations: true,
      experiments: {
        modularCssExternals: true
      }
    });
    styles.set(file, result);
    return result;
  }
  const processor = new _processor.default({
    before: [composesPlugin],
    processing: [exportPlugin],
    after: [stripInlineComments],
    resolvers: [(src, file) => _path.default.resolve(_path.default.dirname(src), file)],
    postcss: {
      syntax: _postcssScss.default
    },
    loadFile: async src => {
      if (deps.has(src)) {
        const hostFile = deps.get(src);
        const result = await runAstroturf(await (0, _promises.readFile)(hostFile, 'utf-8'), hostFile);
        const style = result == null ? void 0 : result.styles.find(s => s.absoluteFilePath === src);
        if (style != null && style.value) {
          return style.value;
        }
      }
      return (0, _promises.readFile)(src, 'utf-8');
    }
  });
  for (const file of files) {
    const content = await (0, _promises.readFile)(file, 'utf-8');
    const astroturf = await runAstroturf(content, file);
    if (!astroturf || !astroturf.styles.length) {
      continue;
    }
    const changeset = [];
    const emptyCss = [];
    await Promise.all(astroturf.styles.map(s => processor.string(s.absoluteFilePath, s.value))).then(processed => {
      processed.forEach((r, idx) => {
        const style = astroturf.styles[idx];
        const isEmpty = !r.details.result.css.trim();
        if (!outFile) {
          if (isEmpty) {
            emptyCss.push(new RegExp(`(import )(.+?from\\s+)["'](${style.requirePath.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, '\\$&')})["'];?`, 'g'));
          } else {
            outFiles.push({
              absoluteFilePath: style.absoluteFilePath,
              value: r.details.result.css
            });
          }
        }
        changeset.push(style);
        if (style.code) {
          changeset.push({
            start: 0,
            end: 0,
            code: `\nconst ${style.importIdentifier} = ${JSON.stringify({
              ...Object.fromEntries(Object.entries(r.details.values).map(([k, v]) => [`@${k}`, v.value])),
              ...r.details.exported,
              ..._output.default.fileCompositions(r.details, processor, {
                joined: true
              })
            }, null, 2)};\n`
          });
        }
      });
    });
    for (const change of astroturf.changeset) {
      if (astroturf.styles.includes(change)) {
        continue;
      }
      if (change.type === 'style-imports') {
        changeset.push({
          ...change,
          code: !outFile ? emptyCss.reduce((code, exp) => code == null ? void 0 : code.replace(exp, ''), change.code).replace(/(import )(.+?from\s+)(.*)/g, '$1$3') : ''
        });
        continue;
      }
      changeset.push(change);
    }
    await (0, _promises.writeFile)(file, (0, _loaders.replaceStyleTemplates)(file, content, changeset, false).code);
  }
  if (outFile) {
    outFiles.push({
      absoluteFilePath: _path.default.isAbsolute(outFile) ? outFile : _path.default.resolve(process.cwd(), outFile),
      value: (await processor.output()).css
    });
  }
  await Promise.all(outFiles.map(style => (0, _promises.writeFile)(style.absoluteFilePath, style.value, 'utf-8')));
}
// eslint-disable-next-line @typescript-eslint/no-unused-expressions
_yargs.default.help().alias('h', 'help').command('*', 'Compile astroturf in files to CSS and class hashes', _ => _.option('css-out-file', {
  alias: 'c',
  type: 'string',
  description: 'The CSS output filename when concat-css is set.'
}).option('config', {
  type: 'string',
  description: 'An astroturf rc file'
}), async ({
  _,
  'css-out-file': cssOutFile,
  config: configFile
}) => {
  const files = await (0, _globby.default)(_);
  await handler({
    files,
    outFile: cssOutFile,
    configFile
  });
}).argv;