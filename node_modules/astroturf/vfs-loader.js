"use strict";

var _path = require("path");
var _util = _interopRequireDefault(require("util"));
var _VirtualModulePlugin = _interopRequireDefault(require("./VirtualModulePlugin"));
var _loaders = require("./utils/loaders");
var _replaceComposes = _interopRequireDefault(require("./utils/replaceComposes"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable max-classes-per-file */

const debug = _util.default.debuglog('astroturf:loader');
const LOADER_PLUGIN = Symbol('loader added VM plugin');
const SEEN = Symbol('astroturf seen modules');
module.exports = async function loader(content, _map, meta) {
  const {
    resourcePath,
    _compilation: compilation
  } = this;
  const cb = this.async();
  if (!compilation[SEEN]) compilation[SEEN] = new Map();
  const loadModule = _util.default.promisify((request, done) => this.loadModule(request, (err, _, _1, module) => done(err, module)));
  const resolve = _util.default.promisify(this.resolve);
  const dependencies = [];
  const buildDependency = async request => {
    const resource = await resolve((0, _path.dirname)(resourcePath), request);
    return loadModule(resource);
  };
  function resolveDependency(interpolation, localStyle, node) {
    const {
      identifier,
      request
    } = interpolation;
    if (!interpolation.identifier) return null;
    const {
      loc
    } = node;
    const memberProperty = 'property' in node && node.property.name;
    const imported = `###ASTROTURF_IMPORTED_${dependencies.length}###`;
    const source = `###ASTROTURF_SOURCE_${dependencies.length}###`;
    debug(`resolving dependency: ${request}`);
    dependencies.push(buildDependency(request).then(({
      styles,
      resource
    }) => {
      const style = styles.find(s => s.identifier === identifier);
      if (!style) {
        throw (0, _loaders.buildDependencyError)(content, interpolation, styles, resource, loc);
      }
      debug(`resolved request to: ${style.absoluteFilePath}`);

      // replace composes first bc we need need to use a different identifier
      localStyle.value = (0, _replaceComposes.default)(localStyle.value, match => match.replace(source, `~${style.absoluteFilePath}`).replace(imported, style.type === 'stylesheet' ? memberProperty : 'cls2'));

      // replace selector interpolations
      localStyle.value = localStyle.value.replace(source, `~${style.absoluteFilePath}`).replace(imported, style.type === 'stylesheet' ? memberProperty : 'cls1');
    }));
    return {
      source,
      imported
    };
  }
  try {
    const options = await (0, _loaders.resolveOptions)(this);
    const {
      styles = [],
      changeset
    } = (0, _loaders.collectStyles)(content, resourcePath, resolveDependency, options);
    if (meta) {
      meta.styles = styles;
    }
    if (!styles.length) {
      return cb(null, content);
    }
    compilation[SEEN].set(resourcePath, styles);
    this._module.styles = styles;
    // @ts-ignore
    let {
      emitVirtualFile
    } = this;

    // The plugin isn't loaded
    if (!emitVirtualFile) {
      const {
        compiler
      } = compilation;
      let plugin = compiler[LOADER_PLUGIN];
      if (!plugin) {
        debug('adding plugin to compiiler');
        plugin = _VirtualModulePlugin.default.bootstrap(compilation);
        compiler[LOADER_PLUGIN] = plugin;
      }
      emitVirtualFile = plugin.addFile;
    }
    return Promise.all(dependencies).then(() => {
      styles.forEach(style => {
        emitVirtualFile(style.absoluteFilePath, style.value);
        // compilation.fileTimestamps.set(style.absoluteFilePath, +mtime);
      });

      const result = (0, _loaders.replaceStyleTemplates)(resourcePath, content, changeset, this.sourceMap);
      cb(null, result.code, result.map);
    }).catch(cb);
  } catch (err) {
    return cb(err);
  }
};