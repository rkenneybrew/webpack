"use strict";

exports.__esModule = true;
exports.default = void 0;
var _helperModuleImports = require("@babel/helper-module-imports");
var t = _interopRequireWildcard(require("@babel/types"));
var _truthy = _interopRequireDefault(require("./truthy"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function findLast(array, predicate) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (predicate(array[i], i, array)) return array[i];
  }
  return undefined;
}
function isRequire(path) {
  const isRequireExpression = p => p.isCallExpression() && p.get('callee').isIdentifier() && p.get('callee').node.name === 'require';
  if (!path) return false;
  if (path.isVariableDeclaration()) {
    return path.get('declarations').some(d => d && isRequireExpression(d.get('init')));
  }
  return isRequireExpression(path);
}
class StyleImportInjector {
  constructor(program) {
    this.nodes = new Set();
    this.code = new WeakMap();
    this.program = program;
  }
  add(style) {
    const {
      scope
    } = this.program;
    const source = style.requirePath;
    const useEsm = (0, _helperModuleImports.isModule)(this.program);
    const ident = scope.generateUidIdentifier(style.identifier);
    if (useEsm) {
      const importNode = t.importDeclaration([t.importDefaultSpecifier(ident)], t.stringLiteral(source));
      this.nodes.add(importNode);
      this.code.set(importNode, `import ${ident.name} from "${source}";`);
    } else {
      const importNode = t.variableDeclaration('const', [t.variableDeclarator(ident, t.callExpression(t.identifier('require'), [t.stringLiteral(source)]))]);
      this.nodes.add(importNode);
      this.code.set(importNode, `const ${ident.name} = require("${source}");`);
    }
    return ident;
  }
  inject() {
    var _targetPath$node;
    const targetPath = findLast(this.program.get('body'), p => {
      var _p$node$_blockHoist;
      // this is a babel mechanism for sorting body blocks
      // I don't want to rely on it, but do want to respect < 1 values as needing to go on the bottom
      // we should not insert below those if possible
      // https://github.com/babel/babel/blob/v7.8.5/packages/babel-core/src/transformation/block-hoist-plugin.js
      //
      // @ts-ignore
      const blockHoist = (_p$node$_blockHoist = p.node._blockHoist) != null ? _p$node$_blockHoist : 1; // eslint-disable-line no-underscore-dangle
      return blockHoist > 0 && (p.isImportDeclaration() || isRequire(p));
    });
    const nodes = Array.from(this.nodes).reverse();
    const end = (targetPath == null ? void 0 : (_targetPath$node = targetPath.node) == null ? void 0 : _targetPath$node.end) || 0;
    const changes = {
      type: 'style-imports',
      end,
      start: end,
      code: `\n${Array.from(this.nodes, n => this.code.get(n)).filter(_truthy.default).join('\n')}\n`
    };
    if (!targetPath) {
      // @ts-ignore
      this.program.unshiftContainer('body', nodes);
    } else {
      for (const node of nodes) {
        targetPath.insertAfter(node);
      }
    }
    this.code = new WeakMap();
    this.nodes.clear();
    return changes;
  }
}
exports.default = StyleImportInjector;