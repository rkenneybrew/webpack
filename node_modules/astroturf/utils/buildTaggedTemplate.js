"use strict";

exports.__esModule = true;
exports.default = buildTaggedTemplate;
var t = _interopRequireWildcard(require("@babel/types"));
var _camelCase = _interopRequireDefault(require("lodash/camelCase"));
var _groupBy = _interopRequireDefault(require("lodash/groupBy"));
var _uniq = _interopRequireDefault(require("lodash/uniq"));
var _cssUnits = _interopRequireDefault(require("./cssUnits"));
var _isCssTag = _interopRequireDefault(require("./isCssTag"));
var _murmurHash = _interopRequireDefault(require("./murmurHash"));
var _processCss = _interopRequireDefault(require("./processCss"));
var _replaceComposes = _interopRequireDefault(require("./replaceComposes"));
var _resolveDependency = _interopRequireDefault(require("./resolveDependency"));
var _trimEnd = _interopRequireDefault(require("./trimEnd"));
var _truthy = _interopRequireDefault(require("./truthy"));
var _wrapInClass = _interopRequireWildcard(require("./wrapInClass"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const rPlaceholder = /###ASTROTURF_PLACEHOLDER_\d*?###/g;
// Match any valid CSS units followed by a separator such as ;, newline etc.
const rUnit = new RegExp(`^(${_cssUnits.default.join('|')})(;|,|\n| |\\))`);
const getPlaceholder = idx => `###ASTROTURF_PLACEHOLDER_${idx}###`;
const toVarsArray = interpolations => {
  const vars = interpolations.map(i => t.arrayExpression((0, _trimEnd.default)([t.stringLiteral(i.id), i.expr.node, i.unit ? t.stringLiteral(i.unit) : null])));
  return t.arrayExpression(vars);
};

/**
 * Build a logical expression returning a class, trying both the
 * kebab and camel case names: `s['fooBar']`
 *
 * @param {String} className
 */
const buildStyleExpression = (id, className) => t.memberExpression(id, t.stringLiteral(className),
// remove the `.`
true);
function assertDynamicInterpolationsLocation(expr, location, opts) {
  var _parent$node$tag;
  const parent = expr.findParent(p => p.isTaggedTemplateExpression());
  // may be undefined in the `styled.button` case, or plain css prop case
  const tagName = parent == null ? void 0 : (_parent$node$tag = parent.node.tag) == null ? void 0 : _parent$node$tag.name;
  const validLocation = location === 'COMPONENT' || location === 'PROP';
  if (!validLocation) {
    const jsxAttr = expr.findParent(p => p.isJSXAttribute());
    if (jsxAttr) {
      const propName = jsxAttr.node.name.name;
      throw jsxAttr.buildCodeFrameError(`This ${tagName} tag with dynamic expressions cannot be used with \`${propName}\` prop. ` + `Dynamic styles can only be passed to the \`css\` prop. Move the style to css={...} to fix the issue${!opts.enableCssProp ? ' (and set the `enableCssProp` to `true` or `"cssProp"` in your astroturf options to allow this feature)' : '.'}`);
    }
    throw expr.buildCodeFrameError('The following expression could not be evaluated during compilation. ' + 'Dynamic expressions can only be used in the context of a component, ' + 'in a `css` prop, or styled() component helper');
  }

  // valid but not configured for this location
  if (validLocation) {
    if (!opts.enableDynamicInterpolations) throw expr.buildCodeFrameError('Dynamic expression compilation is not enabled. ' + 'To enable this usage set the the `enableDynamicInterpolations` to `true` or `"cssProp"` in your astroturf options');
    if (opts.enableDynamicInterpolations === 'cssProp' && location === 'COMPONENT') throw expr.buildCodeFrameError('Dynamic expression compilation is not enabled. ' + 'To enable this usage set the `enableDynamicInterpolations` from `"cssProp"` to `true` in your astroturf options.');
  }
}

/**
 * Traverses an expression in a template string looking for additional astroturf
 * styles. Inline css tags are replaced with an identifier to the class name
 */
function resolveVariants(exprPath, opts, state) {
  const {
    importId
  } = opts;
  const templates = [];
  exprPath.traverse({
    TaggedTemplateExpression(innerPath) {
      if (!(0, _isCssTag.default)(innerPath.get('tag'), opts.pluginOptions)) {
        return;
      }
      if (opts.allowVariants === false) {
        throw innerPath.buildCodeFrameError('Nested Variants are not allowed here');
      }
      if (opts.location !== 'PROP') {
        throw exprPath.buildCodeFrameError('Dynamic variants are only allowed in css props');
      }

      // camel case so we don't need to check multiple cases at runtime
      const classId = (0, _camelCase.default)(`${opts.style.identifier}-variant-${state.id++}`);

      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      const {
        text,
        ...rest
      } = buildTemplateImpl({
        ...opts,
        quasiPath: innerPath.get('quasi'),
        allowVariants: false
      }, state);
      innerPath.replaceWith(buildStyleExpression(importId, classId));
      templates.push({
        text: `.${classId} {\n${text}\n}`,
        ...rest
      });
    }
  });
  return templates;
}
function replaceDependencyPlaceholders(depInterpolations, text, dependencyImports, id, opts) {
  text = (0, _replaceComposes.default)(text, (composes, classList, fromPart) => {
    const composed = classList.map(className => depInterpolations.get(className)).filter(_truthy.default);
    if (!composed.length) return composes;
    if (fromPart) {
      // don't want to deal with this case right now
      throw composed[0].expr.buildCodeFrameError('A styled interpolation found inside a `composes` rule with a "from". ' + 'Interpolated values should be in their own `composes` without specifying the file.');
    }
    if (composed.length < classList.length) {
      throw composed[0].expr.buildCodeFrameError('Mixing interpolated and non-interpolated classes in a `composes` rule is not allowed.');
    }
    return Object.entries((0, _groupBy.default)(composed, i => i.source)).reduce((acc, [source, values]) => {
      const classes = (0, _uniq.default)(
      // We need to to use the class with the styles for composes
      values.map(v => v.imported === 'cls1' ? 'cls2' : v.imported)).join(' ');
      return `${acc ? `${acc};\n` : ''}composes: ${classes} from "${source}"`;
    }, '');
  });
  text = text.replace(rPlaceholder, match => {
    const {
      imported,
      source
    } = depInterpolations.get(match);
    const localName = `a${id++}`;
    if (opts.experiments.modularCssExternals) {
      return `:external(${imported} from "${source}")`;
    }
    dependencyImports += `@value ${imported} as ${localName} from "${source}";\n`;
    return `.${localName}`;
  });
  return [text, dependencyImports];
}
function buildTemplateImpl(opts, state = {
  id: 0
}) {
  const {
    quasiPath,
    nodeMap,
    pluginOptions,
    location,
    style: localStyle
  } = opts;
  const quasi = quasiPath.node;
  const variants = [];
  const depInterpolations = new Map();
  const dynamicInterpolations = new Set();
  const expressions = quasiPath.get('expressions');
  let text = '';
  let dependencyImports = '';
  let lastDynamic = null;
  quasi.quasis.forEach((tmplNode, idx) => {
    const {
      raw
    } = tmplNode.value;
    const expr = expressions[idx];
    let matches;

    // If the last quasi is a replaced dynamic import then see if there
    // was a trailing css unit and extract it as part of the interpolation
    if (lastDynamic && text.endsWith(`var(--${lastDynamic.id})`) && (
    // eslint-disable-next-line no-cond-assign
    matches = raw.match(rUnit))) {
      const [, unit] = matches;
      lastDynamic.unit = unit;
      text += raw.replace(rUnit, '$2');
    } else {
      text += raw;
    }
    if (!expr) {
      return;
    }
    const result = expr.evaluate();
    if (result.confident) {
      text += result.value;
      return;
    }

    // TODO: dedupe the same expressions in a tag
    const resolvedDep = (0, _resolveDependency.default)(expr, nodeMap, localStyle, pluginOptions);
    if (resolvedDep) {
      const ph = getPlaceholder(idx);
      depInterpolations.set(ph, {
        ...resolvedDep,
        expr
      });
      text += ph;
      return;
    }
    const exprNode = expr.node;
    const resolvedInnerTemplates = resolveVariants(expr, opts, state);
    if (resolvedInnerTemplates.length) {
      variants.push({
        expr: exprNode,
        rules: resolvedInnerTemplates
      });
      return;
    }
    assertDynamicInterpolationsLocation(expr, location, pluginOptions);

    // custom properties need to start with a letter
    const id = `a${(0, _murmurHash.default)(`${localStyle.identifier}-${state.id++}`)}`;
    lastDynamic = {
      id,
      expr,
      unit: ''
    };
    dynamicInterpolations.add(lastDynamic);
    text += `var(--${id})`;
  });
  [text, dependencyImports] = replaceDependencyPlaceholders(depInterpolations, text, dependencyImports, state.id, opts.pluginOptions);
  if (dependencyImports) dependencyImports += '\n\n';
  const [rule, imports] = (0, _wrapInClass.hoistImports)(text);
  return {
    variants,
    text: rule,
    imports: `${dependencyImports}${imports.join('\n')}`,
    vars: Array.from(dynamicInterpolations)
  };
}
function buildTaggedTemplate(opts) {
  const {
    location
  } = opts;
  const {
    text,
    vars,
    imports,
    variants
  } = buildTemplateImpl(opts, {
    id: 0
  });
  const allVars = vars;
  const allVariants = [];
  let allImports = imports;
  let css = location === 'STYLESHEET' ? text : (0, _wrapInClass.default)(text);
  for (const variant of variants) {
    allVariants.push(variant.expr);
    for (const rule of variant.rules) {
      allImports += rule.imports;
      allVars.push(...rule.vars);
      css += `\n${rule.text}`;
    }
  }
  css = `${allImports.trim()}\n\n${css}`.trim();
  if (opts.pluginOptions.nesting === true || opts.pluginOptions.nesting === 'auto' && location !== 'STYLESHEET' && opts.style.absoluteFilePath.endsWith('.css')) {
    try {
      css = (0, _processCss.default)(css, opts.style.absoluteFilePath).css;
    } catch {
      /* ignore */
    }
  }
  return {
    css,
    interpolations: allVars.map(({
      expr: _,
      ...i
    }) => i),
    vars: toVarsArray(allVars),
    variants: t.arrayExpression(allVariants)
  };
}